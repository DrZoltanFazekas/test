<html>

<head>
<meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate" />
<meta http-equiv="Pragma" content="no-cache" />
<meta http-equiv="Expires" content="0" />	
</head>
	
<body>

<script src="https://unpkg.com/@walletconnect/client@1.7.8/dist/umd/index.min.js"></script>
<script src="https://unpkg.com/@walletconnect/qrcode-modal@1.7.8/dist/umd/index.min.js"></script>
<script src="https://cdn.ethers.io/lib/ethers-5.2.umd.min.js" type="application/javascript"></script>

<script>

async function test() {

const contractAddress = "0xc99195Ca004B52193B05780c8e2dE02369981599"; //"0x764F7eF98c500eB55Cd2B711eb23839a1AD6c7ba"; // "0x1f16ed9ce7f44f27e7bdb40da97f038f3e71e3d5";
const nftAddress = "0x42d279BF8cbeB96019e42A1A0578c0020b9e3a42"; //"0xeb217b1919f4b76c227b37b79021c196ae2132ea" //"0xB3c4a5D36049651c505435c2214563E9821aBEC6"; // "0xEB217B1919F4B76C227B37B79021c196aE2132EA";
const buyer = "0x0000000000000000000000000000000000000000"; // not dedicated to a specific buyer address
const collection = 12345;
const item = 67901;
const lazymint = true;
const start = "1668166137"; // replace with the unix timestamp when the sale starts
const end = "1700376821"; // replace with the unix timestamp when the sale ends
const price = ethers.utils.parseEther("0.01"); // replace with the price in ETH chosen by the seller
const royalty = 500; // replace with the royalty in myriads (1/10000) choosen by the seller
let signature = "0x78dfe271df0d1491e1c0a603fcb4f14f0768b8e86639786c087c229f3821dc4d67b870a70fd7f7dea6366b0523dfc3c541b702a3a346daa5193f28d3d8b6e9491b"; // replace with signature of the seller

const params = new URLSearchParams(window.location.search);
const metamask = params.has('metamask');

if (metamask) {
  provider = new ethers.providers.Web3Provider(window.ethereum);
  await provider.send("eth_requestAccounts", []);
  signer = provider.getSigner()
}

//const connector = new WalletConnect.default({bridge: "https://bridge.walletconnect.org", qrcodeModal: WalletConnectQRCodeModal.default});
if (params.has('connect')) {
  //connector = connector = new WalletConnect.default({bridge: "https://bridge.walletconnect.org", qrcodeModal: WalletConnectQRCodeModal, clientMeta: {description: "Google DApp", url: "https://www.google.com", icons: ["https://upload.wikimedia.org/wikipedia/commons/archive/5/53/20210618182605%21Google_%22G%22_Logo.svg"], name: "Fake Google DApp"}});
  connector = new WalletConnect.default({bridge: "https://bridge.walletconnect.org", qrcodeModal: WalletConnectQRCodeModal.default});
  if (!connector.connected)
    connector.createSession();
} else
  connector = new WalletConnect.default({session: {"connected":true,"accounts":["0x1fd4d0d877eceddfed0b42a5d6d8bc23e38a450e"],"chainId":5,"bridge":"https://n.bridge.walletconnect.org","key":"b09ca3417568017fe22f5045362fbb00cf2c19d71d73a2b7cc4d4cf9e7fbe94e","clientId":"a655ed28-b619-46c6-a94f-f1ed1fb90d94","clientMeta":{"description":"","url":"http://localhost:8080","icons":[],"name":""},"peerId":"48a06ecb-907e-4b3e-880e-102cc919c7f7","peerMeta":{"description":"MetaMask Mobile app","url":"https://metamask.io","icons":["https://raw.githubusercontent.com/MetaMask/brand-resources/master/SVG/metamask-fox.svg"],"name":"MetaMask","ssl":true},"handshakeId":1669051032221788,"handshakeTopic":"1e0f1e2e-e3bc-49f8-bc1a-bf77bdc6a606"}});

if (metamask)
  account = await signer.getAddress();
else
  account = connector.accounts[0];
console.log(account);

connector.on("connect", async (error, payload) => {
  if (error) throw error;
  const { accounts, chainId } = payload.params[0];
  console.log("connect", accounts, chainId);
  console.log("session", JSON.stringify(connector.session));
});

if (params.has('disconnect'))
  if (connector.connected)
    await connector.killSession();

connector.on("disconnect", async (error, payload) => {
  if (error) {throw error;}
  console.log("disconnect", payload);
});

connector.on("session_update", async (error, payload) => {
    if (error) throw error;
    const { accounts, chainId } = payload.params[0];
    console.log(accounts, chainId);
  });
  
if (metamask) {
	window.ethereum.on('accountsChanged', (newAccounts) => {
      console.log('accounts changed', newAccounts);
    });
    window.ethereum.on('chainChanged', (chainId) => {
      console.log('chain changed', chainId);
    });
}

const req = {
  jsonrpc: "2.0",
  method: "eth_getBalance",
  params: [account],
};

if (params.has('getBalance'))
  if (metamask)
    console.log(ethers.utils.formatEther(await provider.getBalance(account)), "ETH");
  else
    connector.sendCustomRequest(req)
      .then((result) => {console.log("sendCustomRequest", ethers.utils.formatEther(result), "ETH");})
      .catch((error) => {console.error("sendCustomRequest", error);});

tokenId = account.toLowerCase()
  + (collection + 0x1000000000000).toString(16).substr(-12).toLowerCase()
  + (item + 0x10000000000).toString(16).substr(-10).toLowerCase()
  + ((lazymint ? 1 : 0) + 0x100).toString(16).substr(-2).toLowerCase();

const typedData = {
  types: {
    EIP712Domain: [
      { name: "name", type: "string" },
      { name: "version", type: "string" },
      { name: "chainId", type: "uint256" },
      { name: "verifyingContract", type: "address" },
    ],
    verify: [
	  { name: 'seller', type: 'address' },
	  { name: 'buyer', type: 'address' },
	  { name: 'id', type: 'uint256' },
	  { name: 'data', type: 'bytes' },
	  { name: 'start', type: 'uint256' },
	  { name: 'end', type: 'uint256' },
	  { name: 'price', type: 'uint256' },
	  { name: 'royalty', type: 'uint96' },
	  { name: 'royaltyReceiver', type: 'address' },
    ],
  },
  primaryType: "verify",
  domain: {
    name: "LoobTrading",
    version: "1",
    chainId: 5,
    verifyingContract: contractAddress,
  },
  message: {
	seller: account,
	buyer: buyer,
	id: tokenId,
	data: [],
	start: start,
	end: end,
	price: price.toString(),
	royalty: royalty,
	royaltyReceiver: account,
  },
};

if (params.has('sign'))
  if (metamask) {
    signature = await signer._signTypedData(
	  {name: 'LoobTrading', version: '1', 
	    chainId: (await provider.getNetwork()).chainId, //await signer.getChainId(),
	    verifyingContract: contractAddress,
	  }, 
	  {verify: [
	    { name: 'seller', type: 'address' },
		{ name: 'buyer', type: 'address' },
		{ name: 'id', type: 'uint256' },
		{ name: 'data', type: 'bytes' },
		{ name: 'start', type: 'uint256' },
		{ name: 'end', type: 'uint256' },
		{ name: 'price', type: 'uint256' },
		{ name: 'royalty', type: 'uint96' },
		{ name: 'royaltyReceiver', type: 'address' },
	  ]}, 
	  {seller: account,
	   buyer: buyer,
	   id: tokenId,
	   data: [],
	   start: start,
	   end: end,
	   price: price.toString(),
	   royalty: royalty,
	   royaltyReceiver: account,
	  }
	);
	console.log(signature);
  }
  else
    connector.signTypedData([account, JSON.stringify(typedData)])
	  .then((result) => {console.log("sign success", result);}) // result is the signature that must be stored in the database
	  .catch((error) => {console.error("sign failure", error);});

if (metamask)
  contract = new ethers.Contract(contractAddress, [
    "function verify(address seller, uint256 id, bytes memory data, uint256 start, uint256 end, uint256 price, uint96 royalty, address royaltyReceiver, bytes calldata signature) payable",
	"function mint(uint256 id, bytes memory data, uint96 royalty, address royaltyReceiver) payable",
	"event OfferVerified(address indexed seller, address buyer, address indexed royaltyReceiver, uint256 indexed tokenId, uint256 commission, uint256 royalty, uint256 sellerShare)",
  ], signer);
else
  contract = new ethers.Contract(contractAddress, [
    "function verify(address seller, uint256 id, bytes memory data, uint256 start, uint256 end, uint256 price, uint96 royalty, address royaltyReceiver, bytes calldata signature) payable",
	"function mint(uint256 id, bytes memory data, uint96 royalty, address royaltyReceiver) payable",
	"event OfferVerified(address indexed seller, address buyer, address indexed royaltyReceiver, uint256 indexed tokenId, uint256 commission, uint256 royalty, uint256 sellerShare)",
  ]);

transaction = await contract.populateTransaction.verify(
  account, 
  tokenId, 
  [], 
  start, 
  end, 
  price, 
  royalty, 
  account,
  signature, 
  {value: price}
);

if (metamask) { // this block will be used in the backend with an RPC provider, here I use MetaMask instead 
  nft = new ethers.Contract(nftAddress, [
    "function setURI(string memory newuri)",
	"function uri(uint256 _tokenId) view returns (string memory)",
    "event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value)",
  ], provider);
  nft.on("TransferSingle", (operator, from, to, id, value, event) => {console.log(to, "received NFT with tokenId", id.toHexString(), "from", from);});

  contract.on("OfferVerified", (seller, buyer, royaltyReceiver, id, commission, royalty, sellerShare, event) => {console.log(buyer, "paid", commission.toString(), "commission to loob,", royalty.toString(), "royalty to", royaltyReceiver, "and", sellerShare.toString(), "to the seller", seller, "for NFT with tokenId", id.toHexString());});
}

if (params.has('verify'))
  if (!metamask) {
    const tx = {
      from: connector.accounts[0],
      to: transaction.to,
      data: transaction.data,
	  value: price.toString(),
    };
    connector.sendTransaction(tx)
      .then((result) => {console.log("verify success", result);})
      .catch((error) => {console.error("verify failure", error);});
  }
  else {
    tx = await contract.verify(
	  account, 
	  tokenId, 
	  [], 
	  start, 
	  end, 
	  price, 
	  royalty, 
	  account,
	  signature, 
	  {value: price}
	);
    rcpt = await tx.wait();
    console.log(tx, rcpt);
  }

transaction = await contract.populateTransaction.mint(
  tokenId, 
  [], 
  royalty, 
  account,
);

if (params.has('mint'))
  if (!metamask) {
    const tx = {
      from: connector.accounts[0],
      to: transaction.to,
      data: transaction.data,
    };
    connector.sendTransaction(tx)
      .then((result) => {console.log("mint success", result);})
      .catch((error) => {console.error("mint failure", error);});
  }
  else {
    tx = await contract.mint(
	  tokenId, 
	  [], 
	  royalty, 
	  account,
	);
    rcpt = await tx.wait();
    console.log(tx, rcpt);
  }

if (params.has('tokenId'))
  console.log(tokenId);

if (params.has('setUri'))
  if (metamask) {
    tx = await nft.connect(signer).setURI(
	  "https://dev.loob.io/token/"
	);
    rcpt = await tx.wait();
    console.log(tx, rcpt);
  }

if (params.has('getUri'))
  if (metamask) {
	//tokenId = '94052206031540600941348663512987484230918622693045999398077894347736892865537';
	tokenId = '107024718316382381327628361273455731303685784889329407805017337882549441606144';
    uri = await nft.uri(
	  tokenId
	);
    console.log(tokenId, uri);
  }

// einmal
// mein Goerli deployer account ruft nft.grantRole(nft.URI_SETTER_ROLE(), Eds account) auf
// mein Goerli deployer account ruft nft.grantRole(nft.MINTER_ROLE(), loob backend account) auf
// jedes mal bei MINT NOW
// loob backend account signiert mint(uint256 id,bytes data,uint96 royalty,address royaltyReceiver)
// creator account schickt signatur bei mint transaktion mit
// creator account signiert mit lazymint=false verify(address seller,address buyer,uint256 id,bytes data,uint256 start,uint256 end,uint256 price,uint96 royalty,address royaltyReceiver)
}

test();

</script>
</body>
</html>