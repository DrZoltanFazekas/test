<html>

<head>
<meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate" />
<meta http-equiv="Pragma" content="no-cache" />
<meta http-equiv="Expires" content="0" />	
</head>
	
<body>

<button type="button" id="buttonMetaMask">Loading...</button>
<p id="messageMetaMask"></p>

<script src="https://unpkg.com/@metamask/detect-provider/dist/detect-provider.min.js"></script>
<script src="./ethers.umd.min.js"></script>

<script>

window.addEventListener('DOMContentLoaded', async () => {

  const buttonMetaMask = document.getElementById('buttonMetaMask');
  const messageMetaMask = document.getElementById('messageMetaMask');
  
  const ethereum = await detectEthereumProvider({timeout: 6000});
  let provider;
  let accounts;

  const onClickConnect = async () => {
  	buttonMetaMask.innerText = 'Connecting...';
	buttonMetaMask.disabled = true;
	if (!ethereum._state.initialized) {
	  messageMetaMask.innerHTML = 'Reload the page';
	  return; // or call location.reload(true)
	}
	const unlocked = await ethereum._metamask.isUnlocked();
	if (!unlocked)
	  messageMetaMask.innerHTML = 'Enter your password to unlock MetaMask';
	 else
	  messageMetaMask.innerHTML = 'Select one or more accounts to connect';
    try {
      await ethereum.request({ method: 'eth_requestAccounts' });
	  accountReady();	
    } catch (error) {
	  if (error.code === 4001) {
	    messageMetaMask.innerHTML = 'You refused to connect an account';
		accountReady();	
	  } else
	    messageMetaMask.innerHTML = 'Click the MetaMask icon to complete the pending action';
	}
  };

  const accountReady = () => {
    if (!accounts || accounts.length === 0) {
	  messageMetaMask.innerHTML = 'Click here to connect to MetaMask';
      buttonMetaMask.innerText = 'Connect';
      buttonMetaMask.onclick = onClickConnect;
      buttonMetaMask.disabled = false;
	  return false;
    } else {
	  messageMetaMask.innerHTML = accounts[0];
	  buttonMetaMask.innerText = 'Connected';
	  buttonMetaMask.disabled = true;
	  provider = new ethers.providers.Web3Provider(ethereum);
	  return true;
	}
  };

  if (ethereum) {
	ethereum.on('accountsChanged', (newAccounts) => {
      accounts = newAccounts;
      accountReady();
    });
	ethereum.on('chainChanged', (chainId) => {
      console.log(chainId);
    });
	ethereum.on('connect', (connectInfo) => {
      console.log(connectInfo);
    });
	ethereum.on('disconnect', (error) => {
      console.log(error);
    });
    ethereum.on('message', (message) => {
      console.log(message);
    });
    accounts = await ethereum.request({ method: 'eth_accounts' });
  
	if (accountReady()) {
	  var block = await provider.getBlockNumber();
	  console.log("Block number:", block);
	  var bal = await provider.getBalance(accounts[0]);
	  console.log("Balance of " + accounts[0] + ":", bal.toString());

	  var msg = "Hello world";
	  var sig = await provider.getSigner().signMessage(msg);
	  console.log("Signature of", msg, sig);
	  var addr = ethers.utils.verifyMessage(msg, sig);
	  console.log(msg, "was signed by", addr);
messageMetaMask.innerHTML = 'sig ' + sig + ' on ' + msg + ' created by ' + addr;
		
	  if (ethereum.networkVersion === '137') { // benchmark Polygon ERC721 Transfer events
	  var manager = new ethers.Contract("0x4d544035500d7ac1b42329c70eb58e77f8249f0f", ["event Transfer(address indexed from, address indexed to, uint256 amount)"], provider);
	  filter = manager.filters.Transfer();
	  console.log(Date.now());
	  events = await manager.queryFilter(filter, 25360000, 25370000);
	  console.log(Date.now());
	  console.log(events);
	  }
	  else if (ethereum.networkVersion === '1') { // benchmark Mainnet ERC721 Transfer events
	  var manager = new ethers.Contract("0xe2dbd3ef8d0af1b8537fea5817db3508212d677a", ["event Transfer(address indexed from, address indexed to, uint256 amount)"], provider);
	  filter = manager.filters.Transfer();
	  console.log(Date.now());
	  events = await manager.queryFilter(filter, 0, 14415848);
	  console.log(Date.now());
	  console.log(events);
	  }

	  const params = new URLSearchParams(window.location.search);
	  if (params.has('auctionManager') && (ethereum.networkVersion === params.get('networkVersion'))) { // test AuctionManager

	  const abi = [
	    "function m_fee_receiver() view returns (address)",
	    "function withdrawFunds(uint256 amount)",
	    "event CoinDeposit(address indexed m_depositor, uint256 m_amount, uint256 m_free_assets, uint256 m_locked_assets)",
	    "event CoinWithdraw(address indexed m_receiver, uint256 m_amount, uint256 m_free_assets, uint256 m_locked_assets )",
	  ];

	  var manager = new ethers.Contract(params.get('auctionManager'), abi, provider);
	  manager = manager.connect(provider.getSigner());
	
	  var loob = await manager.m_fee_receiver();
	  console.log("Fee receiver:", loob);

	  manager.on("CoinDeposit", (m_depositor, m_amount, m_free_assets, m_locked_assets, event) => {
	    console.log("CoinDeposit(", m_depositor, m_amount, m_free_assets, m_locked_assets, ")");
	  });

	  manager.on("CoinWithdraw", (m_receiver, m_amount, m_free_assets, m_locked_assets, event) => {
	    console.log("CoinWithdraw(", m_receiver, m_amount, m_free_assets, m_locked_assets, ")");
	  });

	  var tx = await provider.getSigner().sendTransaction({
	    to: manager.address,
	    value: ethers.utils.parseEther("10.0")
	  });

	  tx = await manager.withdrawFunds(ethers.utils.parseEther("2.0"));

	  var filter = manager.filters.CoinDeposit(accounts[0]);
	  var events = await manager.queryFilter(filter, 0, block);
	  console.log("CoinDeposit events:", events);
messageMetaMask.innerHTML = 'CoinDeposit events: ' + events.length;
	  }
	}

  }
  
});

</script>

</body>

</html>
